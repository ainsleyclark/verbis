// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"fmt"
	log "github.com/sirupsen/logrus"
	"go/format"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
)

const (
	// The file name to be generated as output.
	blobFileName string = "../updates/blob.go"
)

// Define vars for build template
var (
	tmpl = template.Must(template.New("").Parse(`// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package updates

// Code generated by go generate; DO NOT EDIT.

func init() {
    {{- range $name, $file := . }}
		// Version: {{ $name }}
        UpdateRegistry.Add(Update{
			Version:   "{{ $name }}",
			Migration: "{{ $file }}",
			Callback:  nil,
		})
    {{- end }}
}`))
)

// main
//
// Reads all .go files in the api/directory and encodes
// them as a map in blob.go as a map of filenames and
// the file contents for stack traces.
func main() {

	// Remove file that's already been created
	//_ = os.Remove(blobFileName)

	// Create map for filenames
	stack := make(map[string]string)

	const folder = "./../updates"

	dir, err := os.ReadDir(folder)
	if err != nil {
		die("Error reading updates directory", err)
	}

	for _, v := range dir {
		//versionDir := v.Name()

		fmt.Println(v.Name())
		err := filepath.Walk(filepath.Join(folder, v.Name()), func(path string, info os.FileInfo, err error) error {
			base := filepath.Base(path)

			if base == "callback.go" {
				fmt.Println(path)
			}

			if base == "migration.sql" {
				file, err := ioutil.ReadFile(path)
				if err != nil {
					return err
				}
				stack[v.Name()] = string(file)
			}

			return nil
		})

		if err != nil {
			die("Error walking file directory", err)
		}
	}

	//if strings.HasSuffix(path, ".go") && !strings.Contains(path, "_test.go") {
	//	contents, err := ioutil.ReadFile(path)
	//	if err != nil {
	//		return err
	//	}
	//
	//	file := strings.Replace(path, "../../../", "/verbis/", -1)
	//	fmt.Println(file)
	//	stack[file] = contents
	//}

	if err != nil {
		die("Error walking file directory", err)
	}

	// Create buffer
	builder := &bytes.Buffer{}

	// Execute template
	if err = tmpl.Execute(builder, stack); err != nil {
		die("Error executing template", err)
	}

	// Formatting generated code
	data, err := format.Source(builder.Bytes())
	if err != nil {
		die("Error formatting generated code", err)
	}

	// Writing blob file
	if err = ioutil.WriteFile(blobFileName, data, os.ModePerm); err != nil {
		die("Error writing blob file", err)
	}

	return
}

// die
//
// Exit out of the generation
func die(msg string, err error) {
	if err != nil {
		log.Fatal(msg + ": " + err.Error())
	}
}
